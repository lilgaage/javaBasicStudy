package ObjectOriented.BasicFeature.Extends.AbstractClass;

public class Define {
    /*
    父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。
    那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。
    我们把没有方法主体的方法称为抽象方法。
    java语法规定，包含抽象方法的类就是抽象类。

    定义：
        抽象方法：没有方法体的方法
        抽象类：包含抽象方法的类

    abstract使用格式：
        抽象方法：使用abstract关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，没有方法体
            定义格式：
                修饰符 abstract 返回值类型 方法名(参数列表);
            举例：
                public adstract void run();

        抽象类：如果一个类包含抽象方法，那么该类必须是抽象类
            定义格式：
                abstract class 类名{
                }
            代码举例：
                public abstract class Animal{
                    public abstract void run();
                }

        抽象的使用：继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。
                  最终必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，也失去意义。
            代码举例：
                public class Cat extends Animal {
                    public void run() {
                        System.out.println("小猫在墙头走");
                    }
                }
                public class CatTest {
                    public static void main(String[] args) {
                        Cat cat = new Cat();
                        cat.run();
                    }
                }
                // 输出结果：小猫在墙头走
                // 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重新给的操作叫做实现方法。


        注意事项：
            1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象
                ---假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义
            2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的
                ---子类的构造方法中，有默认的super()，需要访问父类构造方法
            3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定时抽象类
                ---未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计
            4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类
                ---假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义
     */
}
