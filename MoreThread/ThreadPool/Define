使用线程的时候就去创建一个线程，这样实现起来非常方便，但是会有一个问题：
    如果并发的线程数量很多，并且每一个线程都是执行一个时间很短的任务就结束了，
    这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。
    线程池能够时线程复用，执行完一个任务并不会被销毁。


线程池：就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，
    无需反复创建线程而消耗过多资源。
线程池中有很多操作都是与优化资源相关的。
合理利用线程池能够带来三个好处：
    1.降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
    2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    3.提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线程的数组，
        防止因为消耗过多的内存，而把服务器累趴下（每个线程需要大约1mb的内存，线程开的越多，消耗的内存越大，最后死机）



java里面线程池的顶级接口是java.util.concurrent.Executor,但是严格意义上讲Executor并不是一个线程池，
而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService.

要配置一个线程池是比较复杂的，尤其是对于线程池原理不很清楚的情况下，很有可能配置的线程池不是较优的，
因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。
官方建议使用Executors工程类来创建线程池对象。

Executors类中有个创建线程池的方法如下：
    public static ExecutorService newFixedThreadPool(int nThreads): 返回线程池对象
    （创建的是有界线程池，也就是池中的线程个数可以指定最大数量）
获取到了一个线程池ExecutorService对象，定义了一个使用线程池对象的方法：
    public Future<?> submit(Runnable task):获取线程池中的某一个线程对象并执行。
    Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤：
    1.创建线程池对象
    2.创建Runnable接口子类对象（task）
    3.提交Runnable接口子类对象（take task）
    4.关闭线程池（一般不做）