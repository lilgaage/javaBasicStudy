流式思想概述：
    整体来看，流式思想类似于工厂车间的“生产流水线”。
    当需要多个元素进行操作（特别是多部操作时），考虑到性能及便利性，应该首先拼好一个“模型”步骤方案，
    然后再按照方案去执行它。

过滤、映射、跳过、计数等多部操作是一种集合元素的处理方案，
而方案就是一种“函数模型”。调用指定的方法，可以从一个流模型转换为另一个流模型。
filter、map、skip都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法执行的时候，
整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。

备注：Stream流其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）

Stream流是一个来自数据源的元素队列
    元素是特定类型的对象形成一个队列。java中的Stream并不会存储元素，而是按需计算。
    数据源 流的来源，可以是集合、数组等。

和Collection操作不同，Stream操作还有两个基础的特征：
    Pipelining：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，
        如同流式风格fluent style。这样做可以对操作进行优化，比如延迟执行laziness
        和短路short-circuiting
    内部迭代：以前对集合遍历都是通过Iterator或增强for的方式，显式的在集合外部进行迭代，
        这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法

当使用一个流时，通常包括三个基本步骤：获取一个数据源source-->数据转换-->执行操作获取想要的结果，
每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），
这就允许对其操作可以像链条一样排列，变成一个管道。


获取流：java.util.stream.Stream<T>是jdk8新加入的最常用的流接口（这并不是一个函数式接口）
获取一个流非常简单，有以下几种常用的方式：
    所有的Collection集合都可以通过Stream默认方法获取流
    Stream接口的静态方法of可以获取数组对应的流。